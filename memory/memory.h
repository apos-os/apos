// Copyright 2014 Andrew Oates.  All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Basic data structures and constants used by the lowel-level memory code.
#ifndef APOO_MEMORY_MEMORY_H
#define APOO_MEMORY_MEMORY_H

#include <stdbool.h>
#include <stdint.h>

#include "arch/memory/layout.h"
#include "common/types.h"

// A top-level page directory pointer.
// TODO(aoates): redefine this as an arch-specific opaque type.
typedef addr_t page_dir_ptr_t;

// A static memory map entry --- assumed to be virtual addresses unless
// otherwise specified.
typedef struct {
  addr_t base;
  addrdiff_t len;
} smmap_region_t;

// A mapped region.  Gives the physical source region and the virtual base
// address it is mapped to.
typedef struct {
  smmap_region_t phys;
  addr_t virt_base;
} smmap_map_t;

#define MEM_MAX_PHYS_MAPS 2

// A structure generated by load/mem_init.c that describes the layout of virtual
// memory, how much of the kernel is mapped (and where), and what physical pages
// have been allocated thus far.
typedef struct {
  // The physical and virtual addresses of the kernel start and end.
  smmap_map_t kernel;

  // The area of virtual memory that has been mapped containing the kernel
  // binary (so, this _contains_ the kernel_virt region)
  smmap_region_t kernel_mapped;

  // The physical main memory region.
  // TODO(aoates): replace this with a more flexible memory map approach.
  smmap_region_t mainmem_phys;

  // Physical-mapped address regions.  The first phys_map.len bytes of physical
  // memory are mapped directly into the first region.  Other regions are mapped
  // for ad-hoc purposes.  Any memory outside these regions is not mapped.
  smmap_map_t phys_maps[MEM_MAX_PHYS_MAPS];

  // Virtual range of the kernel heap.
  // TODO(aoates): once we have a better VM system set up, use a memory map for
  // this rather than a pseudo-hard-coded range.
  smmap_region_t heap;

  // The allocated size of the heap, in bytes.  This may be set smaller than the
  // virtual range to constrain up-front the amount of heap memory the kernel
  // can allocate.
  size_t heap_size_max;

  // If TSAN is enabled (and supported), the virtual memory range used for the
  // shadow heap.
  smmap_region_t tsan_heap;

  // The base address of the initial kernel stack (used for thread/process 0).
  smmap_region_t thread0_stack;

  // Page directory for the initial address space (used for thread/process 0).
  page_dir_ptr_t kernel_page_directory;
} memory_info_t;

// Once we've finished setting up our initial memory mappings, sets a global
// memory_info_t that is used by the other functions in this module.
void set_global_meminfo(memory_info_t* meminfo);

const memory_info_t* get_global_meminfo(void);

// Returns the page containing the given address.
addr_t addr2page(addr_t addr);

// Returns the next page/frame start address after x (or x if x is
// page-aligned).
addr_t next_page(addr_t x);

// Returns non-zero if the given address is page-aligned.
bool is_page_aligned(addr_t x);

// Converts a physical address to a virtual address (i.e. the virtual location,
// in the kernel's space, where that physical page is mapped, at
// meminfo->phys_map_start).
addr_t phys2virt(phys_addr_t x);

// As phys2virt, but searches _all_ physically-mapped regions (not just the
// primary one), and can fail gracefully if no region contains the address.
// Returns 0 on failure.
addr_t phys2virt_all(phys_addr_t x);

// Converts a virtual address (in the direct-mapped region) to the corresponding
// physical address.
phys_addr_t virt2phys(addr_t x);

// Returns true if the address is a physical address mapped into the
// direct-mapped region (that is, if phys2virt would succeed).
bool is_direct_mappable(phys_addr_t x);

// Returns true if the address is a VIRTUAL address IN the
// direct-mapped region (that is, if virt2phys would succeed).
bool is_direct_mapped(addr_t x);

// Returns true if the address is valid for invoking as a callback.
bool is_valid_callback(void* cb);

#endif
