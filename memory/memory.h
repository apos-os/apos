// Copyright 2014 Andrew Oates.  All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Basic data structures and constants used by the lowel-level memory code.
#ifndef APOO_MEMORY_MEMORY_H
#define APOO_MEMORY_MEMORY_H

#include <stdbool.h>
#include <stdint.h>

#include "arch/memory/layout.h"
#include "common/types.h"

_Static_assert(MEM_USER_STACK_SIZE % PAGE_SIZE == 0,
               "MEM_USER_STACK_SIZE must be an even multiple of PAGE_SIZE");

_Static_assert(MEM_USER_STACK_BOTTOM % PAGE_SIZE == 0,
               "MEM_USER_STACK_BOTTOM must be page aligned");

// A top-level page directory pointer.
typedef addr_t page_dir_ptr_t;

// A structure generated by load/mem_init.c that describes the layout of virtual
// memory, how much of the kernel is mapped (and where), and what physical pages
// have been allocated thus far.
typedef struct {
  // The physical and virtual addresses of the kernel start and end.
  phys_addr_t kernel_start_phys;
  phys_addr_t kernel_end_phys;

  addr_t kernel_start_virt;
  addr_t kernel_end_virt;

  // The area of virtual memory that has been mapped containing the kernel
  // binary.
  addr_t mapped_start;
  addr_t mapped_end;

  // The amount of lower (<1MB) and upper (>1MB) memory available on the
  // machine, in bytes.
  addrdiff_t lower_memory;
  addrdiff_t upper_memory;

  // The location in kernel memory at which the lowest portion of physical
  // memory is mapped.  Any physical address in that region can be accessed by
  // adding this offset to get the corresponding virtual address.
  addr_t phys_map_start;

  // The size of the physically-mapped region.  If there is too much physical
  // memory to fit in the virtual map region, only the lowest X bytes will be
  // mapped.
  addrdiff_t phys_map_length;

  // Start and end (virtual) addresses of the  kernel heap.  The heap consists
  // of memory in the range [heap_start, heap_end).
  // TODO(aoates): once we have a better VM system set up, use a memory map for
  // this rather than a pseudo-hard-coded range.
  addr_t heap_start;
  addr_t heap_end;

  // The base address of the initial kernel stack (used for thread/process 0).
  addr_t kernel_stack_base;

  // Page directory for the initial address space (used for thread/process 0).
  page_dir_ptr_t kernel_page_directory;
} memory_info_t;

// Once we've finished setting up our initial memory mappings, sets a global
// memory_info_t that is used by the other functions in this module.
void set_global_meminfo(memory_info_t* meminfo);

const memory_info_t* get_global_meminfo(void);

// Returns the page containing the given address.
addr_t addr2page(addr_t addr);

// Returns the next page/frame start address after x (or x if x is
// page-aligned).
addr_t next_page(addr_t x);

// Returns non-zero if the given address is page-aligned.
bool is_page_aligned(addr_t x);

// Converts a physical address to a virtual address (i.e. the virtual location,
// in the kernel's space, where that physical page is mapped, at
// meminfo->phys_map_start).
addr_t phys2virt(phys_addr_t x);

// Converts a virtual address (in the direct-mapped region) to the corresponding
// physical address.
phys_addr_t virt2phys(addr_t x);

// Returns true if the address is a physical address mapped into the
// direct-mapped region (that is, if phys2virt would succeed).
bool is_direct_mappable(phys_addr_t x);

// Returns true if the address is a VIRTUAL address IN the
// direct-mapped region (that is, if virt2phys would succeed).
bool is_direct_mapped(addr_t x);

// Converts a physical address IN THE KERNEL to a virtual address IN THE KERNEL
// (i.e.  the virtual location, in the kernel, where that physical page is
// mapped, at 0xc0000000).
//
// This differs from phys2virt in that it only works on addresses in the
// physical kernel loaded at boot, not arbitrary physical addresses.
addr_t phys2kernel(phys_addr_t x);

#endif
