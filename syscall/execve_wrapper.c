// Copyright 2014 Andrew Oates.  All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <stddef.h>

#include "common/errno.h"
#include "common/kassert.h"
#include "common/kstring.h"
#include "memory/kmalloc.h"
#include "proc/exec.h"
#include "syscall/dmz.h"

// Delete a (potentially partial) string table as generated by
// copy_string_table.
static void free_string_table(char** KERNEL_table) {
  for (int i = 0; KERNEL_table[i] != NULL; ++i) {
    kfree(KERNEL_table[i]);
    KERNEL_table[i] = 0x0;
  }
  kfree(KERNEL_table);
}

// Make a copy of the given string table in kernel space.  Returns 0 on success,
// or -errno.
// TODO(aoates): standardize this if it comes up in other syscalls.  Or possibly
// move it to dmz.h/c as a general utility (and unit test it).
static int copy_string_table(const void* table_unchecked,
                             char*** table_out_ptr, bool is64bit) {
  if (is64bit) {
    KASSERT_DBG(sizeof(void*) >= 8);
  }
  *table_out_ptr = NULL;
  const int size = syscall_verify_ptr_table(table_unchecked, is64bit);
  KASSERT(size != 0);
  if (size < 0) return size;

  // Copy the table itself.
  char** KERNEL_table = (char**)kmalloc(sizeof(char*) * size);
  if (!KERNEL_table) return -ENOMEM;

  for (int i = 0; i < size; ++i) KERNEL_table[i] = 0x0;

  // Copy each string in the table.
  for (int i = 0; i < size - 1; ++i) {
    addr_t string_addr = is64bit ? ((addr64_t*)table_unchecked)[i]
                                 : ((addr32_t*)table_unchecked)[i];
    const int string_size = syscall_verify_string((const char*)string_addr);
    if (string_size < 0) {
      free_string_table(KERNEL_table);
      return string_size;
    }

    KERNEL_table[i] = (char*)kmalloc(string_size);
    if (!KERNEL_table[i]) {
      free_string_table(KERNEL_table);
      return -ENOMEM;
    }

    kmemcpy(KERNEL_table[i], (void*)string_addr, string_size);
    KERNEL_table[i][string_size - 1] = '\0';
  }

  *table_out_ptr = KERNEL_table;
  return 0;
}

// Cleanup function to delete kernel copies of the string tables.
static void cleanup(const char* path, char* const argv[], char* const envp[],
                    void* arg) {
  if (path) kfree((void*)path);
  if (argv) free_string_table((char**)argv);
  if (envp) free_string_table((char**)envp);
}

static int execve_wrapper_internal(const char* path_unchecked,
                                   char* const* argv_unchecked,
                                   char* const* envp_unchecked, bool is64bit) {
  // Make a kernel copy of path.
  const int SIZE_path = syscall_verify_string(path_unchecked);
  if (SIZE_path < 0) return SIZE_path;

  char* KERNEL_path = (char*)kmalloc(SIZE_path);
  if (!KERNEL_path) return -ENOMEM;
  kmemcpy(KERNEL_path, path_unchecked, SIZE_path);
  KERNEL_path[SIZE_path - 1] = '\0';

  // Make kernel copies of the tables.
  char** KERNEL_argv = NULL;
  char** KERNEL_envp = NULL;
  int result = copy_string_table(argv_unchecked, &KERNEL_argv, is64bit);
  if (result) {
    cleanup(KERNEL_path, KERNEL_argv, KERNEL_envp, NULL);
    return result;
  }

  result = copy_string_table(envp_unchecked, &KERNEL_envp, is64bit);
  if (result) {
    cleanup(KERNEL_path, KERNEL_argv, KERNEL_envp, NULL);
    return result;
  }

  result = do_execve(KERNEL_path, KERNEL_argv, KERNEL_envp, &cleanup, NULL);
  KASSERT(result != 0);
  cleanup(KERNEL_path, KERNEL_argv, KERNEL_envp, NULL);
  return result;
}

int execve_wrapper(const char* path_unchecked, char* const* argv_unchecked,
                   char* const* envp_unchecked) {
  const bool is64bit = (sizeof(addr_t) == 8);
  return execve_wrapper_internal(path_unchecked, argv_unchecked, envp_unchecked,
                                 is64bit);
}

int execve_wrapper_32(const char* path_unchecked, char* const* argv_unchecked,
                      char* const* envp_unchecked) {
  return execve_wrapper_internal(path_unchecked, argv_unchecked, envp_unchecked,
                                 false);
}
